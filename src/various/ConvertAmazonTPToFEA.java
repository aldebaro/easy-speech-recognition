package various;

import edu.ucsd.asr.Pattern;
import edu.ucsd.asr.SetOfPatterns;
import edu.ucsd.asr.PatternGenerator;
import edu.ucsd.asr.IO;
import edu.ucsd.asr.DirectoryTree;
import edu.ucsd.asr.EmptyPatternGenerator;
import edu.ucsd.asr.Matrix;
import edu.ucsd.asr.FileNamesAndDirectories;

/**
 * Convert files generated by AmazonTP to the FEA format.
 */
public class ConvertAmazonTPToFEA {

  //java -cp \cvs\laps\\ufpaspeech\classes various.ConvertAmazonTPToFEA . 5khz
    public static void main(String[] args) {
      //already ran
      //bin2fea(args);

      //now organize in a way that HMMs can be trained with run.Simulator
      //run this code first for train and later for test
      //go to C:\Datasets\FormasdeondaFEATreino
      organize(args);
    }

    public static void organize(String[] args) {
      if (args.length != 1) {
        System.out.println(
            "Usage: <root directory>");
        System.exit(1);
      }
      //assume the root directory was organized according to the fault labels
      String[] faults = {"AG", "BG", "CG", "AB", "AC", "BC", "ABC", "ABG", "ACG", "BCG", "ABCG"};
      //String[] faults = {"ABC", "AG", "BG"};
      String inputDir = args[0];
      inputDir = FileNamesAndDirectories.replaceAndForceEndingWithSlash(inputDir);

      PatternGenerator patternGenerator = null;

      for (int i = 0; i < faults.length; i++) {
        String dir = inputDir + faults[i].toLowerCase();
        System.out.print("Processing directory " + dir + " ");
        DirectoryTree directoryTree = new DirectoryTree(dir, SetOfPatterns.m_FILE_EXTENSION);
        String[] files = directoryTree.getFilesAsStrings();

        if (files == null || files.length < 1) {
          System.err.println("No files under " + dir);
          System.exit(1);
        }

        SetOfPatterns allSetOfPatterns = null;
        for (int j = 0; j < files.length; j++) {
          SetOfPatterns setOfPatterns = new SetOfPatterns(files[j]);
          if (j == 0) {
            //first iteration
            patternGenerator = setOfPatterns.getPatternGenerator();
            allSetOfPatterns = new SetOfPatterns(patternGenerator);
          }
          //we know there is only 1 patter in setOfPatterns
          allSetOfPatterns.addPattern(setOfPatterns.getPattern(0));
        }
        //write all patterns of this label to one FEA file:
        String outputFile = inputDir + i + "_" + faults[i].toLowerCase() + "." +
                                     SetOfPatterns.m_FILE_EXTENSION;
        allSetOfPatterns.writeToFile(outputFile);
        System.out.println(allSetOfPatterns.getNumberOfPatterns() + " patterns written to " + outputFile);
      }

      //write table of labels
      String header = "TableOfLabels.Type = GENERIC" + IO.m_NEW_LINE +
          "TableOfLabels.nnumberOfEntries = " + faults.length + IO.m_NEW_LINE;
      for (int i = 0; i < faults.length; i++) {
        header += "TableOfLabels.Entry_" + i + " = " + faults[i].toLowerCase() + IO.m_NEW_LINE;
      }

      header += "END_OF_HEADER" + IO.m_NEW_LINE;
      IO.writeStringToFile(inputDir + "tableForScoring.TBL", header);

    }


  public static void bin2fea(String[] args) {
    if (args.length != 2) {
      System.out.println(
          "Usage: <root directory with input file> <input files extension>");
      System.exit(1);
    }

    String dir = args[0];
    String ext = args[1];
    DirectoryTree directoryTree = new DirectoryTree(dir, ext);
    String[] fileNames = directoryTree.getFilesAsStrings();

    PatternGenerator patternGenerator = null;

    for (int i = 0; i < fileNames.length; i++) {
      double[][] dparameters = IO.readMatrixFromBinFile(fileNames[i]);
      //need to transpose
      Pattern pattern = new Pattern(Matrix.transpose(dparameters));
      int numberOfParametersPerFrame = pattern.getNumOfParametersPerFrame();
      if (i == 0) {
        //first iteration
        patternGenerator = new EmptyPatternGenerator(numberOfParametersPerFrame,
            "AmazonTP");
      }
      else {
        //check consistency
        if (numberOfParametersPerFrame !=
            patternGenerator.getNumberOfParameters()) {
          System.err.println("Error: numberOfParametersPerFrame != patternGenerator.getNumberOfParameters(): " +
                             numberOfParametersPerFrame +
                             " != " + patternGenerator.getNumberOfParameters());
          System.exit(1);
        }
      }
      SetOfPatterns setOfPatterns = new SetOfPatterns(patternGenerator);
      setOfPatterns.addPattern(pattern);
      String outputFileName = fileNames[i] + "." +
          SetOfPatterns.m_FILE_EXTENSION;
      setOfPatterns.writeToFile(outputFileName);
      System.out.println("Wrote " + outputFileName);
    }

    System.out.println(fileNames.length + " files processed.");
  }
}
